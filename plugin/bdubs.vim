" bdubs.vim - quickly delete and wipeout buffers
" Author: Josh Branchaud (joshbranchaud.com)
" Version: 0.1


if exists('g:loaded_bdubs')
  finish
endif
let g:loaded_bdubs = 1

let s:save_cpo = &cpo
set cpo&vim


function! s:Reject(list, reject_func)
  return filter(a:list, '!('.a:reject_func.')')
endfunction

function! s:Pluralize(count, singular_form, plural_form)
  if a:count == 1
    return a:count." ".a:singular_form
  else
    return a:count." ".a:plural_form
  endif
endfunction

function! s:BufferNotListed(buffer_number)
  return !buflisted(a:buffer_number)
endfunction

function! s:BufferIsCurrent(buffer_number)
  return bufnr("%") == a:buffer_number
endfunction

function! s:BufferIsModified(buffer_number)
  return getbufvar(a:buffer_number, "&mod")
endfunction

"""
" Most Recently Used Files
"""

if !exists('MRU_Max_Entries')
  let MRU_Max_Entries = 100
endif

if !exists('MRU_File')
  if has('unix') || has('macunix')
    let MRU_File = $HOME . '/.vim_mru_files'
  else
    let MRU_File = $VIM . '/_vim_mru_files'
    if has('win32')
      " MS-Windows
      if $USERPROFILE != ''
        let MRU_File = $USERPROFILE . '\_vim_mru_files'
      endif
    endif
  endif
endif

let s:mru_list_locked = 0

function! s:MRU_LoadList()
  " If the MRU file is present, then load the list of filenames. Otherwise
  " start with an empty list.
  if filereadable(g:MRU_File)
    let s:MRU_files = readfile(g:MRU_File)
    if s:MRU_files[0] =~# '^\s*" Most recently edited files in Vim'
      " Generated by the previous version of the MRU plugin.
      " Discard the list.
      let s:MRU_files = []
    elseif s:MRU_files[0] =~# '^#'
      " Remove the comment line
      call remove(s:MRU_files, 0)
    else
      " Unsupported format
      let s:MRU_files = []
    endif
  else
    let s:MRU_files = []
  endif
endfunction

function! s:MRU_SaveList()
  let l = []
  call add(l, '# Most recently edited files in Vim (version 3.0)')
  call extend(l, s:MRU_files)
  call writefile(l, g:MRU_File)
endfunction

function! s:MRU_AddFile(acmd_bufnr)
  if s:mru_list_locked
    " MRU list is currently locked
    return
  endif

  " Get the full path to the filename
  let fname = fnamemodify(bufname(a:acmd_bufnr + 0), ':p')
  if fname == ''
    return
  endif

  " Skip temporary buffers with buftype set. The buftype is set for buffers
  " used by plugins.
  if &buftype != ''
    return
  endif

  " If the filename is not already present in the MRU list and is not
  " readable then ignore it
  let idx = index(s:MRU_files, fname)
  if idx == -1
    if !filereadable(fname)
      " File is not readable and is not in the MRU list
      return
    endif
  endif

  " Load the latest MRU file list
  call s:MRU_LoadList()

  " Remove the new file name from the existing MRU list (if already present)
  call filter(s:MRU_files, 'v:val !=# fname')

  " Add the new file list to the beginning of the updated old file list
  call insert(s:MRU_files, fname, 0)

  " Trim the list
  if len(s:MRU_files) > g:MRU_Max_Entries
    call remove(s:MRU_files, g:MRU_Max_Entries, -1)
  endif

  " Save the updated MRU list
  call s:MRU_SaveList()
endfunction

"""
" End of Most Recently Used Files
"""

function! s:AllBuffersByNumber()
  let last_buffer = bufnr("$")
  let existing_buffers = filter(range(1, last_buffer), 'bufexists(v:val)')
  return existing_buffers
endfunction

function! s:BufferIsRemoveable(buffer_number, bang)
  return a:bang == '!' || !getbufvar(a:buffer_number, "&mod")
endfunction

function! s:BuffersToRemove(filters)
  let last_buffer = bufnr("$")
  let buffer_list = filter(range(1, last_buffer), 'bufexists(v:val)')
  for filter_func in a:filters
    let buffer_list = s:Reject(buffer_list, filter_func.'(v:val)')
  endfor
  return buffer_list
endfunction

function! s:DeleteBuffers(args, bang)
  let number_of_buffers_to_preserve = str2nr(a:args[0])
  let filters = ['s:BufferIsCurrent']
  let filters += ['s:BufferNotListed']
  if a:bang != '!'
    let filters += ['s:BufferIsModified']
  endif

  let buffer_list = s:BuffersToRemove(filters)
  if number_of_buffers_to_preserve > 1
    let preserve_count = number_of_buffers_to_preserve - 1
    let mru_files_to_preserve = s:MRU_files[0:preserve_count]
    let mru_buffer_numbers = map(mru_files_to_preserve, 'bufnr(v:val."$")')
    let buffer_list = filter(buffer_list, 'index(mru_buffer_numbers, v:val) == -1')
  endif
  let buffer_count = len(buffer_list)

  for buffer_number in buffer_list
    execute buffer_number.'bd'.a:bang
  endfor

  let msg_prefix = s:Pluralize(buffer_count, "buffer", "buffers")
  echomsg msg_prefix." deleted"
endfunction

function! s:WipeoutBuffers(args, bang)
  let number_of_buffers_to_preserve = str2nr(a:args[0])
  let filters = ['s:BufferIsCurrent']
  if a:bang != '!'
    let filters += ['s:BufferIsModified']
  endif

  let buffer_list = s:BuffersToRemove(filters)
  if number_of_buffers_to_preserve > 1
    let preserve_count = number_of_buffers_to_preserve - 1
    let mru_files_to_preserve = s:MRU_files[0:preserve_count]
    let mru_buffer_numbers = map(mru_files_to_preserve, 'bufnr(v:val."$")')
    let buffer_list = filter(buffer_list, 'index(mru_buffer_numbers, v:val) == -1')
  endif
  let buffer_count = len(buffer_list)

  for buffer_number in buffer_list
    execute buffer_number.'bw'.a:bang
  endfor

  let msg_prefix = s:Pluralize(buffer_count, "buffer", "buffers")
  echomsg msg_prefix." wiped out"
endfunction

" Load the MRU list on plugin startup
call s:MRU_LoadList()

" Autocommands to detect the most recently used files
autocmd BufRead * call s:MRU_AddFile(expand('<abuf>'))
autocmd BufNewFile * call s:MRU_AddFile(expand('<abuf>'))
autocmd BufWritePost * call s:MRU_AddFile(expand('<abuf>'))

autocmd QuickFixCmdPre *vimgrep* let s:mru_list_locked = 1
autocmd QuickFixCmdPost *vimgrep* let s:mru_list_locked = 0

command! -nargs=* -bang BD call s:DeleteBuffers( '<args>', '<bang>' )
command! -nargs=* -bang BW call s:WipeoutBuffers( '<args>', '<bang>' )


let &cpo = s:save_cpo
unlet s:save_cpo

" vim:set sw=2 sts=2:
